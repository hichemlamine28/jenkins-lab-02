---
- name: Arrêter la VM si elle existe
  command: virsh destroy "{{ vm_name_prefix }}"
  failed_when: false
  changed_when: false
  # when: destroy | default(false)

- name: Supprimer la VM si elle existe
  command: virsh undefine "{{ vm_name_prefix }}"
  failed_when: false
  changed_when: false
  # when: destroy | default(false)

- name: Supprimer les disques associés
  file:
    path: "{{ vm_dir }}/{{ vm_name_prefix }}.qcow2"
    state: absent
  # when: destroy | default(false)

- name: Supprimer les fichiers cloud-init ISO
  file:
    path: "{{ vm_dir }}/{{ vm_name_prefix }}-cidata.iso"
    state: absent
  # when: destroy | default(false)

- name: Supprimer les fichiers cloud-init user-data/meta-data
  file:
    path: "{{ item }}"
    state: absent
  with_items:
    - "{{ vm_dir }}/{{ vm_name_prefix }}-user-data"
    - "{{ vm_dir }}/{{ vm_name_prefix }}-meta-data"
    - "{{ vm_dir }}/{{ vm_name_prefix }}.xml"
  # when: destroy | default(false)


- name: Créer le dossier de VM s'il n'existe pas
  file:
    path: "{{ vm_dir }}"
    state: directory
    mode: '0755'

- name: Télécharger l’image cloud Ubuntu si absente
  get_url:
    url: "{{ vm_image_url }}"
    dest: "{{ vm_image_path }}"
    mode: '0644'
  when: not lookup('file', vm_image_path, errors='ignore')

- name: Récupérer la clé publique de Jenkins depuis le master
  fetch:
    src: /var/lib/jenkins/.ssh/id_rsa.pub
    dest: /tmp/jenkins_id_rsa.pub
    flat: true
  delegate_to: "{{ groups['master'][0] }}"
  become: true
  become_user: root

- name: Lire la clé publique de Jenkins depuis fichier local
  slurp:
    src: /tmp/jenkins_id_rsa.pub
  register: jenkins_ssh_key

- name: Ajouter la clé publique Jenkins dans ~/.ssh/authorized_keys du host KVM
  authorized_key:
    user: hichem
    state: present
    key: "{{ lookup('file', '/tmp/jenkins_id_rsa.pub') }}"
  become: true
  become_user: hichem

- name: Stocker la clé Jenkins dans une variable
  set_fact:
    ssh_public_key: "{{ jenkins_ssh_key['content'] | b64decode }}"

- name: Générer user-data cloud-init
  template:
    src: cloudinit_user-data.j2
    dest: "{{ vm_dir }}/{{ vm_name_prefix }}-user-data"
  vars:
    user_name: "{{ vm_user }}"
    ssh_key: "{{ ssh_public_key }}"
    password_hash: "{{ vm_password | password_hash('sha512') }}"

- name: Générer meta-data
  copy:
    dest: "{{ vm_dir }}/{{ vm_name_prefix }}-meta-data"
    content: |
      instance-id: {{ vm_name_prefix }}
      local-hostname: {{ vm_name_prefix }}

- name: Créer ISO cloud-init
  command:
    cmd: >
      cloud-localds {{ vm_dir }}/{{ vm_name_prefix }}-cidata.iso
      {{ vm_dir }}/{{ vm_name_prefix }}-user-data
      {{ vm_dir }}/{{ vm_name_prefix }}-meta-data

- name: Créer disque qcow2 différentiel
  command:
    cmd: >
      qemu-img create -f qcow2 -F qcow2 -b {{ vm_image_path }}
      {{ vm_dir }}/{{ vm_name_prefix }}.qcow2 {{ vm_disk_size }}

- name: Générer XML libvirt
  template:
    src: vm_template.xml.j2
    dest: "{{ vm_dir }}/{{ vm_name_prefix }}.xml"

- name: Définir la VM
  command: virsh define "{{ vm_dir }}/{{ vm_name_prefix }}.xml"

- name: Démarrer la VM
  command: virsh start "{{ vm_name_prefix }}"
